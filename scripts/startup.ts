import { createHash } from "crypto";
import fs from "fs";
import connect from "../Modules/database";
import { data, plugins } from "../types/database";
import { compareSemanticVersions } from "../Modules/semantic";
import store from "../types/store";
import upgradeDB from "./upgradeDB";
import dotenv from "dotenv";
import { finished } from "stream/promises";
import { Readable } from "stream";
import { ReadableStream } from "stream/web";
import { setupDB } from "#scripts/setupDB";
if (process.env.APP_ENV !== "test") {
  dotenv.config({ path: ".env.local" });
} else {
  dotenv.config({ path: ".env.test.local" });
}
export const default_theme_dark = JSON.stringify({
  palette: {
    mode: "dark",
    warning: {
      main: "#fdd835",
    },
  },
});
export const default_theme_light = JSON.stringify({
  palette: {
    mode: "light",
    warning: {
      main: "#fbc02d",
    },
  },
});
// Used to tell the program what version the database should get to
const currentVersion = "1.20.3";
// Creates the default config
async function createConfig() {
  const connection = await connect();
  await connection.query(
    "INSERT IGNORE INTO data (value1, value2) VALUES ('configMinTimeGame', '120'), ('configMaxTimeGame', '1200'), ('configMinTimeTransfer', '3600'), ('configMaxTimeTransfer', '86400'), ('configDownloadPicture', 'needed'), ('configDeleteInactiveUser', '0'), ('configArchiveInactiveLeague', '180'), ('configEnablePasswordSignup', ?), ('configThemeDark', ?), ('configThemeLight', ?)",
    [
      process.env.APP_ENV !== "production",
      default_theme_dark,
      default_theme_light,
    ],
  );
  if (process.env.APP_ENV === "test") {
    await connection.query(
      "UPDATE data SET value2='no' WHERE value1='configDownloadPicture'",
    );
  }
  connection.end();
}
// Downloads and generates all the plugin code
async function compilePlugins() {
  const connection = await connect();
  console.log("Compiling plugins");
  let mainFileTextStart = `// Note that this file is autogenerated by startup.ts DO NOT EDIT\nimport dataGetter from "#type/data";\n`;
  let mainFileText =
    "export const plugins: { [key: string]: dataGetter } = {\n";
  const request =
    process.env.APP_ENV !== "test"
      ? await fetch(
          "https://raw.githubusercontent.com/Lukasdotcom/fantasy-manager/main/store/default_store.json",
        ).catch(() => {
          console.error("Could not get the default store");
          return "error";
        })
      : "error";
  const defaultStore: string[] =
    request instanceof Response
      ? await request.json().catch(() => {
          console.error("Could not get the default store");
          return [];
        })
      : // Uses a fallback store if the request fails(this is also the testing store)
        [
          "https://raw.githubusercontent.com/Lukasdotcom/fantasy-manager/main/store/Bundesliga_Testing/Bundesliga_Testing.json",
        ];
  // Installs all plugins that should be installed by default
  await Promise.all(
    defaultStore.map(
      async (e) =>
        await connection.query(
          "INSERT IGNORE INTO plugins (name, settings, enabled, installed, url) VALUES ('', '{}', 0, 0, ?)",
          [e],
        ),
    ),
  );
  // Makes sure that bundesliga is enabled when testing
  if (process.env.APP_ENV === "test") {
    await connection.query("UPDATE plugins SET enabled=1");
  }
  const currentVersion = (await import("../package.json")).default.version;
  // Makes sure that the store is correct
  connection.query(
    "INSERT INTO data VALUES ('defaultStore', ?) ON DUPLICATE KEY UPDATE value2=?",
    [JSON.stringify(defaultStore), JSON.stringify(defaultStore)],
  );
  const plugins = await connection.query("SELECT * FROM plugins");
  await Promise.all(
    plugins.map(
      (e: plugins) =>
        new Promise<void>(async (res) => {
          const data = await fetch(e.url).catch(() => "error");
          if (!(data instanceof Response)) {
            res();
            console.log(`Failed to find plugin at ${e.url}`);
            return;
          }
          const json: store | "error" = await data.json().catch(() => "error");
          if (json === "error") {
            res();
            console.log(`Failed to find plugin at ${e.url}`);
            return;
          }
          connection.query("UPDATE plugins SET name=? WHERE url=?", [
            json.id,
            e.url,
          ]);
          e.name = json.id;
          // Makes sure the plugin is compatible with the current version
          if (
            compareSemanticVersions(
              json.min_version || "0.0.1",
              currentVersion,
            ) === -1
          ) {
            console.error(
              `Plugin ${e.name} is not compatible with the current version of the program`,
            );
            connection.query(
              "UPDATE plugins SET version='', enabled=0, installed=0  WHERE url=?",
              [e.url],
            );
            res();
            return;
          }
          // Creates a hash of the url for storing the plugin in
          const hash = createHash("sha256").update(e.url).digest("hex");
          // Checks if the latest version for the plugin is installed
          if (
            e.version !== json.version ||
            !fs.existsSync("scripts/data/" + hash) ||
            !e.installed
          ) {
            if (e.version === json.version) {
              console.log(`Updating plugin ${e.name}`);
            } else {
              console.log(`Installing plugin ${e.name}`);
            }
            // Downloads the plugin
            if (!fs.existsSync("scripts/data")) {
              fs.mkdirSync("scripts/data");
            }
            // Remove directory if it exists
            if (fs.existsSync("scripts/data/" + hash)) {
              fs.rmSync("scripts/data/" + hash, {
                recursive: true,
                force: true,
              });
            }
            fs.mkdirSync("scripts/data/" + hash);
            // Downloads all the files
            await Promise.all(
              json.files.map(
                (file) =>
                  new Promise<void>(async (res, rej) => {
                    const stream = fs.createWriteStream(
                      __dirname + "/data/" + hash + "/" + file.split("/").pop(),
                    );
                    const { body, status } = await fetch(file);
                    if (!body || status !== 200) {
                      rej();
                      return;
                    }
                    await finished(
                      Readable.fromWeb(body as ReadableStream<Uint8Array>).pipe(
                        stream,
                      ),
                    );
                    res();
                  }),
              ),
            ).then(
              () => {
                console.log(`Finished downloading plugin ${e.name}`);
                mainFileTextStart += `import plugin${hash} from "./data/${hash}";\n`;
                mainFileText += `  "${e.url}":\n    plugin${hash},\n`;
                connection.query(
                  "UPDATE plugins SET version=?, installed=1 WHERE url=?",
                  [json.version, e.url],
                );
              },
              () => {
                console.error(
                  `Failed to download plugin ${e.name}. Restart server to try again.`,
                );
                connection.query(
                  "UPDATE plugins SET version='', enabled=0, installed=0  WHERE url=?",
                  [e.url],
                );
              },
            );
          } else {
            mainFileTextStart += `import plugin${hash} from "./data/${hash}";\n`;
            mainFileText += `  "${e.url}":\n    plugin${hash},\n`;
          }
          res();
        }),
    ),
  );
  mainFileText += "};\nexport default plugins;\n";
  fs.writeFileSync("scripts/data.ts", mainFileTextStart + mainFileText);
  console.log("Done compiling plugins");
}
async function startUp() {
  await setupDB();
  const connection = await connect();
  // Checks if the server hash has been created and if not makes one
  await connection.query(
    "INSERT IGNORE INTO data (value1, value2) VALUES ('serverID', ?)",
    [
      Math.random().toString(36).substring(2) +
        Math.random().toString(36).substring(2),
    ],
  );
  // Unlocks the database
  (await connection.query("SELECT * FROM plugins")).forEach((e: plugins) => {
    connection.query("DELETE FROM data WHERE value1=?", ["locked" + e.name]);
  });
  // Checks the version of the database is out of date
  const getOldVersion: data[] = await connection.query(
    "SELECT value2 FROM data WHERE value1='version'",
  );
  let oldVersion = "";
  if (getOldVersion.length > 0) {
    oldVersion = getOldVersion[0].value2;
    const upgraded = currentVersion !== oldVersion;
    oldVersion = await upgradeDB(oldVersion);
    // HERE IS WHERE THE CODE GOES TO UPDATE THE DATABASE FROM ONE VERSION TO THE NEXT
    if (oldVersion !== currentVersion) {
      // Makes sure that the database is up to date
      console.error("Database is corrupted or is too old");
    }
    // Optimizes the database whenever there is a db upgrade
    if (upgraded) {
      await connection.optimize();
    }
  }
  // Creates the default config if needed
  createConfig();
  // Makes sure that the admin user is the correct user
  await connection.query("UPDATE users SET admin=0");
  if (process.env.ADMIN !== undefined) {
    const adminUser = parseInt(process.env.ADMIN);
    console.log(`User ${adminUser} is the admin user`);
    connection.query("UPDATE users SET admin=1 WHERE id=?", [adminUser]);
  } else {
    console.log("Admin user is disabled");
  }
  // Updated version of database in table
  connection.query(
    "INSERT INTO data (value1, value2) VALUES('version', ?) ON DUPLICATE KEY UPDATE value2=?",
    [currentVersion, currentVersion],
  );
  connection.end();
  compilePlugins();
}
startUp();
